#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;

long long int d[1000001][2];

long long int dp(int x) {
	d[0][0] = 1;
	d[1][0] = 2;
	d[2][0] = 7;
	d[2][1] = 0;

	for (int i = 3; i <= x; i++) {
		// d[i-1][1]은 d[i-4][0]~~d[0][0]의 값들의 합을 의미
		// 따라서 d[i-1][1] + d[i-3][0] = d[i][1]이 된다.
		d[i][1] = (d[i - 1][1] + d[i - 3][0]) % 1000000007;
		d[i][0] = (3 * d[i - 2][0] + 2 * d[i - 1][0] + 2 * d[i][1]) % 1000000007;
	}
	return d[x][0];
}

int main() {
	int x;
	scanf("%d", &x);

	printf("%d\n", dp(x));

	return 0;
}

/*
이번 문제의 경우에는 다양한 경우의 수가
끊임없이 등장하기 떄문에 이를 고려해야한다.

따라서 점화식이 매우 복잡한 구조를 갖게 됩니다.
3부터 한 칸씩 증가할 때마다 고유한 경우의 수가
2개씩 증가하게 되므로 이를 고려하여 점화식을 세워야 한다.

앞의 문제처럼 점화식을 for문을 활용해 구현하면 옳은 결과를
출력할 수는 있게 되지만, 문제에서 요구하는 시간을 초과하기
때문에, 이를 해결하기 위해 2차 메모이제이션을 사용하게 됩니다.
*/